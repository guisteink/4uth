const mongoose = require("mongoose");

const { Schema } = mongoose;
const jwt = require("jsonwebtoken");
const uniqueValidator = require("mongoose-unique-validator");
const crypto = require("crypto");

const { secret } = require("../configs");

const validEmailRegex = /\S+@\S+\.\S+/;
const validUsernameRegex = /^[a-zA-Z0-9]+$/;

const UserSchema = new Schema(
  {
    username: {
      type: String,
      lowercase: true,
      unique: true,
      required: [true, "can't be empty"],
      match: [validUsernameRegex, "is invalid"],
      index: true,
    },
    email: {
      type: String,
      lowercase: true,
      unique: true,
      required: [true, "can't be empty"],
      match: [validEmailRegex, "is invalid"],
      index: true,
    },
    role: {
      type: String,
      lowercase: true,
      enum: ["admin", "manager", "user"],
      default: "user",
    },
    avatar: String,
    hash: { type: String, selected: false },
    salt: { type: String, selected: false },
  },
  { timestamps: true }
);

function getTokenFromHeader(req) {
  if (
    (req.headers.authorization &&
      req.headers.authorization.split(" ")[0] === "Token") ||
    (req.headers.authorization &&
      req.headers.authorization.split(" ")[0] === "Bearer")
  ) {
    return req.headers.authorization.split(" ")[1];
  }

  return null;
}

/**
 * Adds a plugin that checks if the unique fields of the model
 * are really unique and generates a custom error message if they are not.
 */
UserSchema.plugin(uniqueValidator, { message: "is already taken" });

/**
 * Verifies if the password provided by the user matches the password
 * stored in the database, by comparing the encrypted hashes of the two passwords.
 */
UserSchema.methods.validPassword = function (password) {
  const hash = crypto
    .pbkdf2Sync(password, this.salt, 10000, 512, "sha512")
    .toString("hex");
  return this.hash === hash;
};

/**
 * Sets the user's password by encrypting it with a random encryption
 * key (salt) and storing the resulting hash in the database.
 */
UserSchema.methods.setPassword = function (password) {
  if (!password) {
    throw new Error("Password must be provided");
  }

  this.salt = crypto.randomBytes(16).toString("hex");
  this.hash = crypto
    .pbkdf2Sync(password, this.salt, 10000, 512, "sha512")
    .toString("hex");
};

/**
 * Generates a JSON Web Token (JWT) for the user, which is used for
 * authentication purposes. The token contains the user's id, username,
 * and an expiration date (2 days from today). The token is signed with
 * a secret key that is only known by the server. */
UserSchema.methods.generateJWT = function () {
  const today = new Date();
  const exp = new Date(today);
  exp.setDate(today.getDate() + process.env.EXPIRATION_TIME ?? 2);

  return jwt.sign(
    {
      id: this._id,
      username: this.username,
      [this.role === "admin"
        ? "isAdmin"
        : this.role === "manager"
          ? "isManager"
          : "isUser"]: true, // prettier-ignore
      exp: parseInt(exp.getTime() / 1000, 10),
    },
    secret
  );
};

/**
 * Returns an object that contains the user's authentication data,
 * including the username, email, a JWT token generated by the
 * generateJWT() method, and optional data such as bio and image.
 * This object is typically used to send authentication data back
 * to the client-side application.
 */
UserSchema.methods.toAuthJSON = function () {
  return {
    username: this.username,
    email: this.email,
    token: this.generateJWT(),
    bio: this.bio,
    image: this.image,
  };
};

/** Decodes a JWT token by extracting it from the authorization
 * header of a request and using a secret key. The decoded token
 * contains user information that can be used to check if the user
 * is authorized to perform certain actions in the application. */
UserSchema.statics.getJwtContent = function (request) {
  const token = getTokenFromHeader(request);

  const decoded = jwt.verify(token, secret);
  return decoded;
};

const User = mongoose.model("User", UserSchema);

module.exports = User;
